// Copyright (C) 2002-2017 Tuma Solutions, LLC
// Process Dashboard - Data Automation Tool for high-maturity processes
//
// This program is free software; you can redistribute it and/or
// modify it under the terms of the GNU General Public License
// as published by the Free Software Foundation; either version 3
// of the License, or (at your option) any later version.
//
// Additional permissions also apply; see the README-license.txt
// file in the project root directory for more information.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, see <http://www.gnu.org/licenses/>.
//
// The author(s) may be contacted at:
//     processdash@tuma-solutions.com
//     processdash-devel@lists.sourceforge.net

package net.sourceforge.processdash.tool.probe.wizard;

import java.io.PrintWriter;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import net.sourceforge.processdash.data.SimpleData;
import net.sourceforge.processdash.data.repository.DataRepository;
import net.sourceforge.processdash.i18n.Resources;
import net.sourceforge.processdash.util.FormatUtil;
import net.sourceforge.processdash.util.HTMLUtils;
import net.sourceforge.processdash.util.StringUtils;


public abstract class ProbeMethod implements Comparable {

    protected static Resources resources =
        Resources.getDashBundle("PROBE.Wizard");

    /** A list of observations (in HTML format) made during the
     * calculation of this estimate. */
    protected List observations;

    /** A list of messages (in HTML format) describing errors
     * encountered during the calculation of this estimate. */
    protected List errorMessages;

    /** The rating given to this method. */
    protected double rating = 0.0;
    protected static final double CANNOT_CALCULATE = -100.0;
    protected static final double SERIOUS_PROBLEM = -10.0;
    protected static final double PROBE_METHOD_D = 5.0;


    /** Historical data */
    protected ProbeData histData;

    /** Which PROBE method? (e.g. A B C) */
    protected String methodLetter;
    protected MethodPurpose methodPurpose;

    /** Is this method currently selected? */
    protected boolean isSelected;
    /** Is this method the only option listed? */
    protected boolean isOnly;
    /** Is this method the best option available? */
    protected boolean isBest;

    /** Estimated object LOC */
    protected double inputValue;
    protected double outputValue;
    protected double outputRange;
    protected double beta0;
    protected double beta1;
    protected double rangePercent;
    protected double standardDeviation;
    protected double correlation;
    protected double significance;


    /** Perform the calculations required for this PROBE Method. */
    public ProbeMethod(ProbeData data, String letter, MethodPurpose purpose) {
        this.observations = new LinkedList();
        this.errorMessages = new LinkedList();
        this.rating = PROBE_METHOD_D;
        this.histData = data;
        this.methodLetter = letter;
        this.methodPurpose = purpose;
        this.isSelected = this.isOnly = this.isBest = false;

        this.inputValue = this.outputValue = this.outputRange = this.beta0 =
            this.beta1 = this.rangePercent = this.standardDeviation =
            this.correlation = this.significance = Double.NaN;
    }

    public abstract void calc();
//    protected abstract String getTutorialURL();
    protected abstract String getTutorialLink();

    /** Return a confidence rating describing the relative quality
     * of the estimate generated by this probe method.
     *
     * Various ratings and their meanings:<ul>
     *    <li> rating &gt;= +10 - excellent
     *    <li> rating = 5 - PROBE method D
     *    <li> rating = 0 - ambivalent
     *    <li> -1 &lt; rating &lt; 0 - "not recommended"
     *    <li> rating &lt;= -1.0 - "cannot calculate"
     * </ul>
     * The user will not be given an option of selecting methods
     * which have negative ratings. This method should not return
     * NaN or Infinity.
     */
    public double getRating() { return rating; }


    /** implement the <code>Comparable</code> interface. */
    public int compareTo(Object o) {
        double myRating = getRating();
        double yourRating = ((ProbeMethod) o).getRating();
        if (myRating > yourRating) return -1; // sort descending
        if (myRating < yourRating) return 1;
        return 0;
    }

    public String getMethodLetter() {
        return methodLetter;
    }

    protected String getMethodName() {
        return resources.format("Method_FMT", methodLetter, getPurposeLabel());
    }

    protected String getPurposeLabel() {
        return resources.getString(methodPurpose.getKey());
    }

    protected String getMethodShortName() {
        return resources.format("Method_Short_FMT", methodLetter);
    }

    protected String formatMethodTutorial(String text) {
        return getTutorialLink() + text + "</a>";
    }

    public void printOption(PrintWriter out) {
        if (getRating() < 0)
            out.print(NBSP);

        else {
            String purposeKey = methodPurpose.getKey();
            String letter = getMethodLetter();
            String qual = purposeKey + letter;

            out.print("<input type='radio' ");
            if (isSelected) out.print("checked ");
            out.print("name='" + purposeKey + "' ");
            out.print("value='" + letter + "'><tt>");
            out.print(methodPurpose.formatValue(outputValue, outputRange));
            out.print(NBSP + NBSP + NBSP + "</tt>");
            printField(out, FLD_ESTIMATE, qual, outputValue);
            printField(out, FLD_BETA0, qual, beta0);
            printField(out, FLD_BETA1, qual, beta1);
            printField(out, FLD_RANGE, qual, outputRange);
            printField(out, FLD_PERCENT, qual, rangePercent);
            printField(out, FLD_CORRELATION, qual, correlation);
            out.println("<!-- rating = " + rating + " -->");
            out.println("<!-- input = " + inputValue + " -->");
        }
    }



    protected void printField(PrintWriter out, String name,
                              String qual, double value) {
        out.print("<input type='hidden' name='");
        out.print(qual);
        out.print(name);
        out.print("' value='");
        out.print(value);
        out.print("'>\n");
    }

    public void printExplanation(PrintWriter out) {
        if (errorMessages.size() > 0) {
            String resKey;
            if (getRating() > CANNOT_CALCULATE)
                resKey = "Method.Serious_Error_Message_FMT";
            else
                resKey = "Method.Fatal_Error_Message_FMT";
            out.println(resources.format
                        (resKey, formatMethodTutorial(getMethodShortName())));

            for (Iterator i = errorMessages.iterator(); i.hasNext();)
                out.println(Tutorial.annotate((String) i.next()));

        } else {
            if (!isOnly) {
                String resKey;
                if (isBest)
                    resKey = "Method.Best_Message_FMT";
                else
                    resKey = "Method.Next_Best_Message_FMT";
                out.println(resources.format
                            (resKey,
                             formatMethodTutorial(getMethodShortName()),
                             getPurposeLabel().toLowerCase()));
            }

            for (Iterator i = observations.iterator(); i.hasNext();)
                out.println(Tutorial.annotate((String) i.next()));
        }
    }

    public void printChart(PrintWriter out) {
        String params = buildXYChartParams();
        if (params == null)
            out.print(NBSP);
        else {
            out.print("<a href=\"../full.htm?chart=xy&autoZero&");
            out.print(params);
            out.print("\" onclick=\"return popup(this.href);\">");
            out.print("<img border=\"0\" src=\"../xy.class?autoZero&");
            out.print(params);
            out.print("&qf=probe/small.rpt\" width=\"100\" height=\"115\">");
            out.print("</a>\n");
        }
    }



    protected String buildXYChartParams() {
        return null;
    }

    protected static String formatNumber(double num) {
        return FormatUtil.formatNumber(num);
    }

    protected static boolean badDouble(double d) {
        return Double.isNaN(d) || Double.isInfinite(d);
    }

    protected String esc(String s) {
        return HTMLUtils.escapeEntities(s);
    }


    public static final String FLD_ESTIMATE = "Estimate";
    public static final String FLD_BETA0 = "Beta0";
    public static final String FLD_BETA1 = "Beta1";
    public static final String FLD_RANGE = "Range";
    public static final String FLD_PERCENT = "Percent";
    public static final String FLD_CORRELATION = "Corr";

    static final String NBSP = "&nbsp;";
    static final String PLUS_MINUS = "&plusmn;";

    public static double RANGE_PERCENT = 0.70;

    public void setBest(boolean isBest) { this.isBest = isBest; }
    public void setOnly(boolean isOnly) { this.isOnly = isOnly; }
    public void setSelected(boolean selected) { this.isSelected = selected; }


    public static String getSelectedMethod(DataRepository data, String prefix,
                                           String targetDataElem) {
        String dataName = DataRepository.createDataName
            (prefix, targetDataElem + "/Probe Method");
        SimpleData val = data.getSimpleValue(dataName);
        return (val == null ? null : val.format());
    }



    public static void writeReportTableHeader(PrintWriter out,
            boolean inverseBeta1) {
        String tableHeader =
            "<tr>" +
            "<th ALIGN='RIGHT'>${Method_Label}</th>" +
            "<th>${Estimate_Label}</th>" +
            "<th>&nbsp; ${R_Squared} &nbsp;</th>" +
            "<th>${Beta0}</th>" +
            "<th>%INV%${Beta1}</th>" +
            "<th>${Range} (%PCT%)</th>" +
            "<th>&nbsp;${LPI}&nbsp;</th>" +
            "<th>&nbsp;${UPI}&nbsp;</th>" +
            "<th>${Variance}</th>" +
            "<th>${Standard_Deviation}</th>" +
            "<th>${Comments}</th></tr>";

        tableHeader = resources.interpolate
            (tableHeader, HTMLUtils.ESC_ENTITIES);
        tableHeader = StringUtils.findAndReplace
            (tableHeader, "%INV%", inverseBeta1 ? "1/" : "");
        tableHeader = StringUtils.findAndReplace
            (tableHeader, "%PCT%",
             FormatUtil.formatPercent(ProbeMethod.RANGE_PERCENT));
        tableHeader = Tutorial.annotate(tableHeader);

        out.println(tableHeader);
    }

    public void printReportRow(PrintWriter out) {
        if (getRating() > CANNOT_CALCULATE && !badDouble(outputValue)) {
            out.println("<tr>");
            out.print("<td ALIGN='RIGHT'>");
            if (isSelected)
                out.print("<img src='rarrow.gif' width=14 height=13>&nbsp;");
            out.print(formatMethodTutorial(getMethodLetter()));
            out.print("</td>");

            printReportTableCell(out, outputValue);
            printReportTableCell(out, correlation);
            printReportTableCell(out, beta0);
            printReportTableCell(out, beta1, methodPurpose.formatBeta1(beta1));
            printReportTableCell(out, outputRange);
            double lpi = outputValue - outputRange; if (lpi < 0) lpi = 0;
            printReportTableCell(out, lpi);
            double upi = outputValue + outputRange; if (upi < 0) upi = 0;
            printReportTableCell(out, upi);
            double variance = standardDeviation * standardDeviation;
            printReportTableCell(out, variance);
            printReportTableCell(out, standardDeviation);
            out.print("<td ALIGN='CENTER'>");
            if (isSelected)
                out.print("<b>"+resources.getHTML("Method.Selected")+"</b> ");
            if (rating <= SERIOUS_PROBLEM)
                out.print("<i>"+resources.getHTML("Method.Do_Not_Use")+"</i>");
            out.println("</td></tr>");
        }
    }
    private void printReportTableCell(PrintWriter out, double val) {
        printReportTableCell(out, val, null);
    }
    private void printReportTableCell(PrintWriter out, double num, String str) {
        out.print("<td ALIGN='CENTER'>");
        if (badDouble(num))
            out.print("&nbsp;");
        else
            out.print(str != null ? str : formatNumber(num));
        out.println("</td>");
    }

}
